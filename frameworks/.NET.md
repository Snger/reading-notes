## What's ASP.NET?
1. ASP.NET is an open-source server-side web application framework designed for web development to produce dynamic web pages. It was developed by Microsoft to allow programmers to build dynamic web sites, web applications and web services.
2. It was first released in January 2002 with version 1.0 of the .NET Framework, and is the successor to Microsoft's Active Server Pages (ASP) technology. ASP.NET is built on the Common Language Runtime (CLR), allowing programmers to write ASP.NET code using any supported .NET language. The ASP.NET SOAP extension framework allows ASP.NET components to process SOAP messages.
3. ASP.NET's successor is ASP.NET Core. It is a re-implementation of ASP.NET as a modular web framework, together with other frameworks like Entity Framework. The new framework uses the new open-source .NET Compiler Platform (codename "Roslyn") and is cross platform. ASP.NET MVC, ASP.NET Web API, and ASP.NET Web Pages (a platform using only Razor pages) have merged into a unified MVC 6.

## What's ADO.NET?
1. ADO.NET is a set of classes that expose data access services for .NET Framework programmers. ADO.NET provides a rich set of components for creating distributed, data-sharing applications. It is an integral part of the .NET Framework, providing access to relational, XML, and application data. ADO.NET supports a variety of development needs, including the creation of front-end database clients and middle-tier business objects used by applications, tools, languages, or Internet browsers.
2. ADO.NET separates data access from data manipulation into discrete components that can be used separately or in tandem. ADO.NET includes .NET Framework data providers for connecting to a database, executing commands, and retrieving results. Those results are either processed directly, placed in an ADO.NET DataSet object in order to be exposed to the user in an ad hoc manner, combined with data from multiple sources, or passed between tiers. The DataSet object can also be used independently of a .NET Framework data provider to manage data local to the application or sourced from XML.
3. The ADO.NET classes are found in System.Data.dll, and are integrated with the XML classes found in System.Xml.dll. 
4. ADO.NET provides the most direct method of data access within the .NET Framework. For a higher-level abstraction that allows applications to work against a conceptual model instead of the underlying storage model, see the ADO.NET Entity Framework.

## What's ADO.NET DataSet?
1. The ADO.NET DataSet is a memory-resident representation of data that provides a consistent relational programming model regardless of the source of the data it contains. A DataSet represents a complete set of data including the tables that contain, order, and constrain the data, as well as the relationships between the tables.

## LINQ to DataSet
1. LINQ to DataSet makes it easier and faster to query over data cached in a DataSet object. Specifically, LINQ to DataSet simplifies querying by enabling developers to write queries from the programming language itself, instead of by using a separate query language. This is especially useful for Visual Studio developers, who can now take advantage of the compile-time syntax checking, static typing, and IntelliSense support provided by the Visual Studio in their queries.
2. LINQ to DataSet can also be used to query over data that has been consolidated from one or more data sources. This enables many scenarios that require flexibility in how data is represented and handled, such as querying locally aggregated data and middle-tier caching in Web applications. In particular, generic reporting, analysis, and business intelligence applications require this method of manipulation.
3. The LINQ to DataSet functionality is exposed primarily through the extension methods in the DataRowExtensions and DataTableExtensions classes.

## LINQ: .NET Language-Integrated Query
1. Language Integrated Query (LINQ, pronounced "link") is a Microsoft .NET Framework component that adds native data querying capabilities to .NET languages, although ports exist for PHP (PHPLinq), JavaScript (linq.js), TypeScript (linq.ts), and ActionScript (ActionLinq) - but none of these ports are strictly equivalent to LINQ in C# for example (where it is a part of the language, not an external library, and where it often addresses a wider range of needs).
2. .NET Language-Integrated Query defines a set of general purpose standard query operators that allow traversal, filter, and projection operations to be expressed in a direct yet declarative way in any .NET-based programming language. The standard query operators allow queries to be applied to any IEnumerable<T>-based information source. LINQ allows third parties to augment the set of standard query operators with new domain-specific operators that are appropriate for the target domain or technology. More importantly, third parties are also free to replace the standard query operators with their own implementations that provide additional services such as remote evaluation, query translation, optimization, and so on. By adhering to the conventions of the LINQ pattern, such implementations enjoy the same language integration and tool support as the standard query operators.
3. The extensibility of the query architecture is used in the LINQ project itself to provide implementations that work over both XML and SQL data. The query operators over XML (LINQ to XML) use an efficient, easy-to-use, in-memory XML facility to provide XPath/XQuery functionality in the host programming language. The query operators over relational data (LINQ to SQL) build on the integration of SQL-based schema definitions into the common language runtime (CLR) type system. This integration provides strong typing over relational data while retaining the expressive power of the relational model and the performance of query evaluation directly in the underlying store.
4. Getting Started with Standard Query Operators
````C#
using System;
using System.Linq;
using System.Collections.Generic;
class app {
  static void Main() {
    string[] names = { "Burke", "Connor", "Frank", 
                       "Everett", "Albert", "George", 
                       "Harris", "David" };

    IEnumerable<string> query = from s in names 
                               where s.Length == 5
                               orderby s
                               select s.ToUpper();

    foreach (string item in query)
      Console.WriteLine(item);
  }
}
````
5. The local variable query is initialized with a query expression. A query expression operates on one or more information sources by applying one or more query operators from either the standard query operators or domain-specific operators. This expression uses three of the standard query operators: Where, OrderBy, and Select.
6. method-based query
````C#
IEnumerable<string> query = names 
    .Where(s => s.Length == 5) 
    .OrderBy(s => s)
    .Select(s => s.ToUpper());
````
7. This form of query is called a method-based query. The arguments to the Where, OrderBy, and Select operators are called lambda expressions, which are fragments of code much like delegates. They allow the standard query operators to be defined individually as methods and strung together using dot notation. Together, these methods form the basis for an extensible query language.
8. The namespace System.Linq.Expressions defines a distinguished generic type, Expression<T>, which indicates that an expression tree is desired for a given lambda expression rather than a traditional IL-based method body. Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the expression transparent and explicit.
9. The determination of whether the compiler will emit executable IL or an expression tree is determined by how the lambda expression is used. When a lambda expression is assigned to a variable, field, or parameter whose type is a delegate, the compiler emits IL that is identical to that of an anonymous method. When a lambda expression is assigned to a variable, field, or parameter whose type is Expression<T> for some delegate type T, the compiler emits an expression tree instead.

## Extension Methods
1. Lambda expressions are one important piece of the query architecture. Extension methods are another. Extension methods combine the flexibility of "duck typing" made popular in dynamic languages with the performance and compile-time validation of statically-typed languages. With extension methods third parties may augment the public contract of a type with new methods while still allowing individual type authors to provide their own specialized implementation of those methods.
2. Extension methods are defined in static classes as static methods, but are marked with the [System.Runtime.CompilerServices.Extension] attribute in CLR metadata. Languages are encouraged to provide a direct syntax for extension methods. In C#, extension methods are indicated by the this modifier which must be applied to the first parameter of the extension method. Let's look at the definition of the simplest query operator, Where:
````C#
namespace System.Linq {
  using System;
  using System.Collections.Generic;

  public static class Enumerable {
    public static IEnumerable<T> Where<T>(
             this IEnumerable<T> source,
             Func<T, bool> predicate) {

      foreach (T item in source)
        if (predicate(item))
          yield return item;
    }
  }
}
````
3. The type of the first parameter of an extension method indicates what type the extension applies to. In the example above, the Where extension method extends the type IEnumerable<T>. 

## Retrieving and Modifying Data in ADO.NET
1. A primary function of any database application is connecting to a data source and retrieving the data that it contains. The .NET Framework data providers of ADO.NET serve as a bridge between an application and a data source, allowing you to execute commands as well as to retrieve data by using a DataReader or a DataAdapter. A key function of any database application is the ability to update the data that is stored in the database. In ADO.NET, updating data involves using the DataAdapter and DataSet, and Command objects; and it may also involve using transactions.

## Connecting to a Data Source in ADO.NET
1. In ADO.NET you use a Connection object to connect to a specific data source by supplying necessary authentication information in a connection string. The Connection object you use depends on the type of data source.
2. Each .NET Framework data provider included with the .NET Framework has a DbConnection object: the .NET Framework Data Provider for OLE DB includes an OleDbConnection object, the .NET Framework Data Provider for SQL Server includes a SqlConnection object, the .NET Framework Data Provider for ODBC includes an OdbcConnection object, and the .NET Framework Data Provider for Oracle includes an OracleConnection object.

## Transactions and Concurrency
1. A transaction consists of a single command or a group of commands that execute as a package. Transactions allow you to combine multiple operations into a single unit of work. If a failure occurs at one point in the transaction, all of the updates can be rolled back to their pre-transaction state.
2. A transaction must conform to the ACID properties—atomicity, consistency, isolation, and durability—in order to guarantee data consistency. Most relational database systems, such as Microsoft SQL Server, support transactions by providing locking, logging, and transaction management facilities whenever a client application performs an update, insert, or delete operation.
3. [Note] Transactions that involve multiple resources can lower concurrency if locks are held too long. Therefore, keep transactions as short as possible.
4. If a transaction involves multiple tables in the same database or server, then explicit transactions in stored procedures often perform better. You can create transactions in SQL Server stored procedures by using the Transact-SQL BEGIN TRANSACTION, COMMIT TRANSACTION, and ROLLBACK TRANSACTION statements. For more information, see SQL Server Books Online.

## What's ACID?
1. Atomic – All statements in the transaction either completed successfully or they were all rolled back. The task that the set of operations represents is either accomplished or not, but in any case not left half-done, to the detriment of your data.
2. Consistent – All data touched by the transaction is left in a logically consistent state. For example, if inventory numbers were decremented in one table, there has to be a related order that consumed that inventory. The inventory can't just disappear.
3. Isolated – The transaction must affect data without interfering with other concurrent transactions, or being interfered with by them. This prevents transactions from making changes to data based on uncommitted information, for example changes to a record that are subsequently rolled back. Most databases use locking to maintain transaction isolation.
4. Durable – The data changes enacted by the transaction are permanent, and will persist through a system failure.

## Anatomy of a Transaction
> A transaction at its most basic level consists of two required steps—Begin, and then either Commit or Rollback. The Begin call defines the start of the transaction boundary, and the call to either Commit or Rollback defines the end of it. Within the transaction boundary, all of the statements executed are considered to be part of a unit for accomplishing the given task, and must succeed or fail as one. Commit (as the name suggests) commits the data modifications if everything was successful, and Rollback undoes the data modifications if an error occurs. All of the .NET data providers provide similar classes and methods to accomplish these operations.

## Local Transactions
> Transactions in ADO.NET are used when you want to bind multiple tasks together so that they execute as a single unit of work. For example, imagine that an application performs two tasks. First, it updates a table with order information. Second, it updates a table that contains inventory information, debiting the items ordered. If either task fails, the both updates are rolled back.

## Determining the Transaction Type
1. A transaction considered to be a local transaction when it is a single-phase transaction and is handled by the database directly. Transactions are considered to be distributed transactions when they are coordinated by a transaction monitor and use fail-safe mechanisms (such as two-phase commit) for transaction resolution.
2. Each of the .NET Framework data providers has its own Transaction object for performing local transactions. If you require a transaction to be performed in a SQL Server database, select a System.Data.SqlClient transaction. For an Oracle transaction, use the System.Data.OracleClient provider. In addition, there is a new DbTransaction class that is available for writing provider-independent code that requires transactions.

## [System.Data.Common] DbTransaction Class
1. The base class for a transaction.
2. Namespace:   System.Data.Common; Assembly:  System.Data (in System.Data.dll)
3. Version Information: Universal Windows Platform - Available since 10 , .NET Framework - Available since 2.0
4. Thread Safety - Any public static ( Shared in Visual Basic) members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
5. [Method] Commit(): Commits the database transaction.
5. [Method] Dispose(Boolean): Releases the unmanaged resources used by the DbTransaction and optionally releases the managed resources.
5. [Method] Rollback(): Rolls back a transaction from a pending state.

## WebMatrix.Data Namespace
1. The WebMatrix.Data namespace contains classes that simplify database interaction in ASP.NET Web Pages. This namespace includes classes that help you to open, query, and send commands to a database, and to work with database rows that are returned by SQL queries.
2. [Class]Database: Provides methods and properties that are used to access and manage data that is stored in a database.

## WebMatrix.Data Database Class
1. Provides methods and properties that are used to access and manage data that is stored in a database.
2. [Property]Connection: Gets the current connection to a database.
3. [Method]OpenConnectionString(String): Opens a connection to a database using the specified connection string.
3. [Method]OpenConnectionString(String, String): Opens a connection to a database using the specified connection string.
3. [Method]Query: Executes a SQL query that returns a list of rows as the result.
3. [Method]Execute: Executes a non-query SQL statement.
3. [Method]Close: Closes an open database.
3. [Method]Dispose(): Releases all resources used by a Database instance.
3. [Method]Dispose(Boolean): Releases the unmanaged resources used by a Database instance and optionally releases the managed resources.

## System.Web Namespaces
1. The System.Web namespaces contain types that enable browser/server communication. Child namespaces include types that support ASP.NET forms authentication, application services, data caching on the server, ASP.NET application configuration, dynamic data, HTTP handlers, JSON serialization, incorporating AJAX functionality into ASP.NET, ASP.NET security, and web services.

## System.Web Namespace
1. The System.Web namespace supplies classes and interfaces that enable browser-server communication. This namespace includes the HttpRequest class, which provides extensive information about the current HTTP request; the HttpResponse class, which manages HTTP output to the client; and the HttpServerUtility class, which provides access to server-side utilities and processes. System.Web also includes classes for cookie manipulation, file transfer, exception information, and output cache control.
2. The System.Web namespace contains extension class for HTTP context.
3. [Class] HttpContextBaseExtensions: Provides extension methods for HttpContextBase.
4. [Class] HttpContextExtensions: Provides extension methods for HttpContext.

## HttpContext Class
1. Encapsulates all HTTP-specific information about an individual HTTP request.
2. [Constructor] HttpContext(HttpRequest, HttpResponse): Initializes a new instance of the HttpContext class by using the specified request and response objects.
3. [Constructor] HttpContext(HttpWorkerRequest): Initializes a new instance of the HttpContext class that uses the specified worker-request object.

## ASP.NET C# Static Variables are global?
1. For non-generic types there is a single static variable per AppDomain
2. For generic types there is one per generic instantiation per AppDomain
3. Static classes and class members are used to create data and functions that can be accessed without creating an instance of the class. Static class members can be used to separate data and behavior that is independent of any object identity: the data and functions do not change regardless of what happens to the object. Static classes can be used when there is no data or behavior in the class that depends on object identity.
4. A static method, field, property, or event is callable on a class even when no instance of the class has been created. If any instances of the class are created, they cannot be used to access the static member. Only one copy of static fields and events exists, and static methods and properties can only access static fields and static events. Static members are often used to represent data or calculations that do not change in response to object state; for instance, a math library might contain static methods for calculating sine and cosine.
5. Not sure how many people realize it, but when you start dealing with multiple users access a system (in this case a web server), you have to be very careful what you store in static’s (global variables).  This is because all the users will have access to this data and so if you create a page, you could allow them to see data that they shouldn’t.

## Generic Type Parameters (C# Programming Guide)
1. In a generic type or method definition, a type parameters is a placeholder for a specific type that a client specifies when they instantiate a variable of the generic type. 

## Global.asax Syntax
1. The Global.asax file, also known as the ASP.NET application file, is an optional file that contains code for responding to application-level and session-level events raised by ASP.NET or by HTTP modules. The Global.asax file resides in the root directory of an ASP.NET application. At run time, Global.asax is parsed and compiled into a dynamically generated .NET Framework class derived from the HttpApplication base class. ASP.NET is configured so that any direct URL request for the Global.asax file is automatically rejected; external users cannot download or view the code in it.
2. The Global.asax file is optional. You create it only if you want to handle application or session events.
3. uses Global.asax for some "global" variables, So from the ASPX pages, you can access those members by opening up the static Global class

## HttpApplication.BeginRequest Event
1. Occurs as the first event in the HTTP pipeline chain of execution when ASP.NET responds to a request.
2. The BeginRequest event signals the creation of any given new request. This event is always raised and is always the first event to occur during the processing of a request.

## ControllerBase.ViewBag Property
1. Gets the dynamic view data dictionary.
2. The ViewBag property enables you to dynamically share values from the controller to the view. It is a dynamic object which means it has no pre-defined properties. You define the properties you want the ViewBag to have by simply adding them to the property. In the view, you retrieve those values by using same name for the property.

## StreamReader Class
1. Implements a TextReader that reads characters from a byte stream in a particular encoding.
2. Namespace: System.IO , Assembly: mscorlib (in mscorlib.dll)
3. [method] ReadToEnd(): Reads all characters from the current position to the end of the stream.(Overrides TextReader.ReadToEnd().)

## HttpServerUtility.MapPath Method (String); (Server.MapPath)
1. Returns the physical file path that corresponds to the specified virtual path.
2. Namespace: System.Web ; Assembly: System.Web (in System.Web.dll)
3. If path is null, the MapPath method returns the full physical path of the directory that contains the current request for the path. The relative path does not need to specify an existing file or folder for this method to return a value. However, you cannot specify a path outside of the Web application.
4. "this.httpContext.Server" is a reference to HttpServerUtilityBase, the abstract class wrapper that's a part of the System.Web.Abstractions DLL. You can also do: `HttpContext.Current.Server`
5. To directly access the "old-school" way. Also you can get an instance of the base class using the wrapper by doing the following: `new HttpServerUtilityWrapper(HttpContext.Current.Server)` The wrapper class inherits from httpServerUtilityBase
6. HttpContext Class: Encapsulates all HTTP-specific information about an individual HTTP request.
7. HttpContext.Server Property: Gets the HttpServerUtility object that provides methods used in processing Web requests.
8. [Remarks] The Server property provides programmatic access to the properties and methods of the HttpServerUtility class. Because ASP.NET pages contain a default reference to the System.Web namespace (which contains the HttpContext class), you can reference the members of HttpContext on an .aspx page without using the fully qualified class reference to HttpContext. For example, you can use Server.CreateObject("MyCOMComponent") to create an instance of a COM object on the server. However, if you want to use the members of HttpServerUtility from an ASP.NET code-behind module, you must include a reference to the System.Web namespace in the module and a fully qualified reference to both the currently active request/response context and the class in System.Web that you want to use. For example, in a code-behind page you must specify the fully qualified name HttpContext.Current.Server.CreateObject("MyCOMComponent").

## Newtonsoft.Json.Linq
1. LINQ to JSON is an API for working with JSON objects. It has been designed with LINQ in mind to enable quick querying and creation of JSON objects. LINQ to JSON sits under the Newtonsoft.Json.Linq namespace.
2. JSON values can be read from a string using Parse(String).

## Newtonsoft.Json.Linq.JObject
1. Represents a JSON object.
2. [Constructor] JObject(): Initializes a new instance of the JObject class.
3. [Constructor] JObject(Object): Initializes a new instance of the JObject class with the specified content.
4. [Propertie] Value<T>: Gets the JToken with the specified key converted to the specified type. (Inherited from JToken.)
5. [Propertie] Values<T>: Returns a collection of the child values of this token, in document order. (Inherited from JContainer.)

## How can I read a text file without locking it?
1. You need to make sure that both the writer and the reader open the log file non-exclusively.
2. For the reader use a FileStream instance but change the file access: `var inStream = new FileStream(logfileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);`
3. FileStream Constructor (String, FileMode, FileAccess, FileShare): Initializes a new instance of the FileStream class with the specified path, creation mode, read/write permission, and sharing permission.
4. [Parameters] mode, Type: System.IO.FileMode - A constant that determines how to open or create the file.
> FileMode Enumeration: Specifies how the operating system should open a file.
> Member name: Append, Create, CreateNew, Open, OpenOrCreate, Truncate
5. [Parameters] access, Type: System.IO.FileAccess - A constant that determines how the file can be accessed by the FileStream object. This also determines the values returned by the CanRead and CanWrite properties of the FileStream object. CanSeek is true if path specifies a disk file.
> FileAccess Enumeration: Defines constants for read, write, or read/write access to a file. This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.
> Member name: Read, ReadWrite, Write
6. [Parameters] share, Type: System.IO.FileShare - A constant that determines how the file will be shared by processes. A typical use of this enumeration is to define whether two processes can simultaneously read from the same file. For example, if a file is opened and Read is specified, other users can open the file for reading but not for writing.
> FileShare Enumeration: Contains constants for controlling the kind of access other FileStream objects can have to the same file. This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.
> Member name: Delete, Inheritable, None, Read, ReadWrite, Write

## C# Language Features Accessors Properties
1. The accessor of a property contains the executable statements associated with getting (reading or computing) or setting (writing) the property. The accessor declarations can contain a get accessor, a set accessor, or both. The declarations take the following forms: set {accessor-body} get {accessor-body} where: `accessor-body` The block that contains the statements to be executed when the accessor is invoked.
2. The get Accessor: The body of the get accessor is similar to that of a method. It must return a value of the property type. The execution of the get accessor is equivalent to reading the value of the field. The following is a get accessor that returns the value of a private field name, When you reference the property, except as the target of an assignment, the get accessor is invoked to read the value of the property. The get accessor must terminate in a return or throw statement, and control cannot flow off the accessor body.
3. The set Accessor: The set accessor is similar to a method that returns void. It uses an implicit parameter called value, whose type is the type of the property. In the following example, a set accessor is added to the Name property, When you assign a value to the property, the set accessor is invoked with an argument that provides the new value. It is an error to use the implicit parameter name (value) for a local variable declaration in a set accessor.

## What is the { get; set; } syntax in C#?
1. In C# 3.0 and later, auto-implemented properties make property-declaration more concise when no additional logic is required in the property accessors. They also enable client code to create objects. When you declare a property as shown in the following example, the compiler creates a private, anonymous backing field that can only be accessed through the property's get and set accessors.
2. In C# 6 and later, you can initialize auto-implemented properties similarly to fields: `public string FirstName { get; set; } = "Jane";` 
3. Attributes are permitted on auto-implemented properties but obviously not on the backing fields since those are not accessible from your source code. If you must use an attribute on the backing field of a property, just create a regular property.

## What is the 'dynamic' type in C# 4.0 used for?
1. The dynamic keyword is new to C# 4.0, and is used to tell the compiler that a variable's type can change or that it is not known until runtime. Think of it as being able to interact with an Object without having to cast it.
2. Visual C# 2010 introduces a new type, dynamic. The type is a static type, but an object of type dynamic bypasses static type checking. In most cases, it functions like it has type object. At compile time, an element that is typed as dynamic is assumed to support any operation. Therefore, you do not have to be concerned about whether the object gets its value from a COM API, from a dynamic language such as IronPython, from the HTML Document Object Model (DOM), from reflection, or from somewhere else in the program. However, if the code is not valid, errors are caught at run time.
3. The dynamic type enables the operations in which it occurs to bypass compile-time type checking. Instead, these operations are resolved at run time. The dynamic type simplifies access to COM APIs such as the Office Automation APIs, and also to dynamic APIs such as IronPython libraries, and to the HTML Document Object Model (DOM).
4. Type dynamic behaves like type object in most circumstances. However, operations that contain expressions of type dynamic are not resolved or type checked by the compiler. The compiler packages together information about the operation, and that information is later used to evaluate the operation at run time. As part of the process, variables of type dynamic are compiled into variables of type object. Therefore, type dynamic exists only at compile time, not at run time.

## Null-Conditional Operator
1. Null-Conditional Operator is new to C# 6.0, Null values complicate code. You need to check every access of variables to ensure you are not dereferencing null. The null conditional operator makes those checks much easier and fluid.
2. Simply replace the member access `.` with `?.`: `var first = person?.FirstName; ` The right hand side operand of the ?. operator is not limited to properties or fields. You can also use it to conditionally invoke methods. The most common use of member functions with the null conditional operator is to safely invoke delegates (or event handlers) that may be null. You'll do this by calling the delegate's Invoke method using the ?. operator to access the member.
3. The rules of the ?. operator ensure that the left-hand side of the operator is evaluated only once. This is important and enables many idioms, including the example using event handlers. 
4. The compiler generates code for the ?. operator that ensures the left side (this.SomethingHappened) of the ?. expression is evaluated once, and the result is cached: `this.SomethingHappened?.Invoke(this, eventArgs);` 

## DescriptionAttribute Class
1. Specifies a description for a property or event.
2. Namespace:   System.ComponentModel, Assembly:  System (in System.dll)
3. [Constructors] DescriptionAttribute(String): Initializes a new instance of the DescriptionAttribute class with a description.
4. [Properties] Description: Gets the description stored in this attribute.
5. [Properties] DescriptionValue: Gets or sets the string stored as the description.
6. [Remarks] A visual designer can display the specified description when referencing the component member, such as in a Properties window. Call Description to access the value of this attribute.

## Can I use threads to carry out long-running jobs on IIS?
1. You can accomplish what you want, but it is typically a bad idea. Several ASP.NET blog and CMS engines take this approach, because they want to be installable on a shared hosting system and not take a dependency on a windows service that needs to be installed. Typically they kick off a long running thread in Global.asax when the app starts, and have that thread process queued up tasks.
2. In addition to reducing resources available to IIS/ASP.NET to process requests, you also have issues with the thread being killed when the AppDomain is recycled, and then you have to deal with persistence of the task while it is in-flight, as well as starting the work back up when the AppDomain comes back up.
3. Keep in mind that in many cases the AppDomain is recycled automatically at a default interval, as well as if you update the web.config, etc.
4. If you can handle the persistence and transactional aspects of your thread being killed at any time, then you can get around the AppDomain recycling by having some external process that makes a request on your site at some interval - so that if the site is recycled you are guaranteed to have it start back up again automatically within X minutes.
5. Again, this is typically a bad idea.
6. EDIT (from the far distant future) - These days I would use Hangfire.
7. ASP.NET is not designed for long-running tasks, yes. But only because their work and data can be lost at any time when the worker process restarts.
8. You do not keep any state between iterations of your task. The task can safely abort at any time. This is safe to run in ASP.NET.
9. Starting the thread in Application_Start is a problem because that function can be called multiple times (surprisingly). I suggest you make sure to only start the deletion task once, for example by using `Lazy<T>` and accessing its Value property in Application_Start.
10. For some reason I cannot think of a better init-once pattern right now. Nothing without locks, volatile or Interlocked which are solutions of last resort.


