## EJB 最初要要解决什么问题？产生了什么新的问题？
> 初衷：EJB 提供了一种（由 J2EE 平台级别的）组件模式，该模式可以让开发人员仅关注系统业务方面的开发，而忽略中间件需求，例如组件、事务管理、持久化操作、安全性、资源池、线程、分发、远程处理等。开发人员可以任何时候将中间件需求的服务添加到系统中。
> 问题：
> 1. EJB 2.x 规范要求组件接口和业务逻辑实现都必须从 EJB 框架包中扩展接口，从而在开发人员便携的代码和来自 EJB 框架包的接口类之间产生耦合。同时，EJB 2.x 还要求实现几个不必要的回调方法，比如 ejbCreate、ejbPassivate 和 ejbActivate，而这些回调方法与 EJB 的主要设计目的并无直接关系。
> 2. 可测试性是原来的 EJB 编程模型的最大问题之一。在 EJB 容器之外测试 Session 和 EntityBeans 几乎是不可能的；
> 3. 部署过程是 EJB 编程模型的另一个耗时且易于出错的阶段。……开发人员通常尝试手动维护这些文件，这样就容易在包或者类名中出现简单的拼写错误，而这些错误直到部署阶段才会被注意到。
> 4. 将开发人员的转向面向过程程序设计风格。
> 5. EJB 通过远程方法调用（Remote Method Invocation, RMI）是 Web 层和服务层工作，这样做实际等同于具有了单独的物理层。
> 6. 一次性写入，随处运行 »»» 一次性写入，随处调试

## POJO 编程模型的优点
> 1. 编写应用程序类非常快速和简单。这是因为所编写的类不需要依赖任何特定的 API（所以可以非常容易地通过网络进行传输在不同层之间使用），不需要实现任何特定的接口或者拓展来自某一特定的框架类。开发人员不需要创建任何特殊的回调方法，除非缺失需要使用这些方法。

## 轻量级容器
> 1. EJB 虽然有很多弊端，但这个容器的优点和概念为人们所熟悉，并加以借鉴。
> 2. 因此，在实践中，拥有如下一个环境可能更好：在改环境中，所有组件都被创建和装配，并且提供了所需的中间件服务，这样一个环境被称为容器（container）。
> 3. 根据 Rod Johnson 和 Jurgen holler 所编写的《Expert One-on-One J2EE Development Without EJB(Wrox, 2004)，任何容器都应该能够想该环境中所管理的组件提供基本的服务：生命周期管理、依赖解析、组件查找、应用程序配置。如果能提供如下中间件服务，那就更好了：事务管理、安全性、线程管理、对象和资源池、对组件的远程访问、通过 JMX 之类的 API 管理组件、容器的拓展和定制。
> 4. 一个轻量级容器（lightweight container）包括所有上述功能，但不需要为了依赖这些 API 而编写应用程序代码。也就是说，轻量级容器没有侵入特性，启动非常快，并且不需要将其部署到一个功能齐全的 Java EE 应用程序服务器上。

## 控制反转
1. 容器及起管理的组件所提供的最重要的好处是可插拔的体系结构。组件需要实现一些接口，并且可以通过类似的接口访问其他组件所提供的服务。组件不需要知道这些服务的具体实现类。因此，可以非常容易地使用一个不同的实现替换系统中的任何组件。而容器的工作则是船舰这些组件以及所依赖的服务，并将这些组件组装在一起。
2. 在组件类中，不需要使用新的操作服来实例化依赖组件，而是在运行时有容器实例将依赖组件注入组件。因此，对依赖想的控制有组件传到容器。这种模式被称为“控制反转”（Inversion of Controll, IoC）。可以通过好莱坞原则“不要给我们打电话，我们会给你打电话(don't cll us, we'll call you)”来更好的理解 IoC 的重要性。
3. IoC 被认为是任何容器都需要提供的基本功能之一。它主要有两种形式：依赖查找（dependency lookup）和依赖注入（dependency injection）。
4. 在依赖查找中，容器想起管理的组件提供了回调方法，而组件则通过这些回调方法与容器进行交互并显示地获取他们的依赖项。这种情况下，通常使用一个查找上下文（Java Naming and Directory Interface (JNDI) 上下文) 来访问依赖组件以及容器管理的其他资源。
5. 在依赖注入中，组件提供了合适的构造函数或 Setter 方法，一遍容器可以注入依赖组件。一般来说，很少在组件内执行显示依赖查找，大多情况下，是通过构造函数或 Setter 方法在创建组件的时候注入依赖项。
6. 随着 Spring Application Framework 以及其他轻量级 IoC 框架的出现，依赖注入方法逐渐变得流行起来。这种情况下，组件如何实例化以及需要那些依赖组件则完全由容器自己的配置机制来确定。容器的任务是处理相关的配置信息，以便在运行时实例化所需要的组件并装配依赖项。在 J2EE 想 Java EE 的演化过程中，使用 JNDI 进行的显示依赖查找被逐步转化为隐式依赖注入方法。

## 依赖注入
1. 开发人员可以使用两种依赖注入方法。一种方法是构造函数注入，另一种是 Setter 注入。一个好的容器应该可以同时支持这两种方法，并且允许混合使用。
2. 