# C++
<!-- MarkdownTOC -->

- gcc version
- Compiling a C++ program with gcc
- G++ undefined reference to class::function
- g++ 应用说明
- g++ 常用命令选项
- << 运算符
- typedef 声明
- 枚举类型
- C++ 中的变量声明
- C++ 中的左值（Lvalues）和右值（Rvalues）
- static 存储类
- extern 存储类
- 位运算符
- 杂项运算符
- C++ 中的运算符优先级
- Lambda 函数与表达式
- C++ 字符串
- C 风格字符串
- C++ 中的 String 类
- C++ 指针
- C++ 中使用指针
- C++ 引用
- 可重载运算符/不可重载运算符
- 虚函数
- C++ 接口（抽象类）
- C++析构函数（Destructor）

<!-- /MarkdownTOC -->


## gcc version
	$ gcc -v
	$ g++ -v

## Compiling a C++ program with gcc
> use g++ instead of gcc to compile you c++ source.

## G++ undefined reference to class::function
> [so](https://stackoverflow.com/questions/19661406/g-undefined-reference-to-classfunction#19662783)
This is a linker error. Try:
`g++ test.cpp Telephone.cpp -o test`
Basically, the linker is complaining about functions you used but didn't provide an implementation for. To see all the steps the compiler performs for you, throw in a -v:
`g++ -v test.cpp Telephone.cpp -o test`

## g++ 应用说明
> 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：
	$ gcc main.cpp -lstdc++ -o main
最简单的编译方式：
	$ g++ helloworld.cpp
由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：
	$ ./a.out
	Hello, world!
通常我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：
	$ g++ helloworld.cpp -o helloworld
如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：
	$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob
生成一个 runoob 可执行文件。
g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：
	g++ -g -Wall -std=c++11 main.cpp

## g++ 常用命令选项
> 选项	解释
-ansi	只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。
-c	只编译并生成目标文件。
-DMACRO	以字符串"1"定义 MACRO 宏。
-DMACRO=DEFN	以字符串"DEFN"定义 MACRO 宏。
-E	只运行 C 预编译器。
-g	生成调试信息。GNU 调试器可利用该信息。
-IDIRECTORY	指定额外的头文件搜索路径DIRECTORY。
-LDIRECTORY	指定额外的函数库搜索路径DIRECTORY。
-lLIBRARY	连接时搜索指定的函数库LIBRARY。
-m486	针对 486 进行代码优化。
-o	FILE 生成指定的输出文件。用在生成可执行文件时。
-O0	不进行优化处理。
-O	或 -O1 优化生成代码。
-O2	进一步优化。
-O3	比 -O2 更进一步优化，包括 inline 函数。
-shared	生成共享目标文件。通常用在建立共享库时。
-static	禁止使用共享连接。
-UMACRO	取消对 MACRO 宏的定义。
-w	不生成任何警告信息。
-Wall	生成所有警告信息。

## << 运算符
> 本实例使用了 endl，这将在每一行后插入一个换行符，<< 运算符用于向屏幕传多个值。

## typedef 声明
> 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：
	typedef type newname; 
> 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：
	typedef int feet;

## 枚举类型
> 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。
> 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。
> 创建枚举，需要使用关键字 enum。枚举类型的一般形式为：
	enum 枚举名{ 
	     标识符[=整型常数], 
	     标识符[=整型常数], 
	... 
	    标识符[=整型常数]
	} 枚举变量;
> 如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。
例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。
	enum color { red, green, blue } c;
	c = blue;
> 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。
	enum color { red, green=5, blue };
在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。

## C++ 中的变量声明
> 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。
> 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。
````C++
#include <iostream>
using namespace std;
// 变量声明
extern int a, b;
extern int c;
extern float f;
  
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;
 
  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;
}
````

## C++ 中的左值（Lvalues）和右值（Rvalues）
> C++ 中有两种类型的表达式：
> - 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
> - 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：
	int g = 20;
但是下面这个就不是一个有效的语句，会生成编译时错误：
	10 = 20;

## static 存储类
> static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
> static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
> 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

## extern 存储类
> extern  存储类用于提供一个全局变量的引用， 全局变量对所有的程序文件都是可见的。当您使用 'extern' 时， 对于无法初始化的变量， 会把变量名指向一个之前定义过的存储位置。
> 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时， 可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解， extern 是用来在另一个文件中声明一个全局变量或函数。
> - extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候

## 位运算符
> 位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：
````
p	q	p & q	p | q	p ^ q
0	0	0		0		0
0	1	0		1		1
1	1	1		1		0
1	0	0		1		1
````
> 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：
````
运算符	描述	实例
&	如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。	(A & B) 将得到 12，即为 0000 1100
|	如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。	(A | B) 将得到 61，即为 0011 1101
^	如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。	(A ^ B) 将得到 49，即为 0011 0001
~	二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。	(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。
<<	二进制左移运算符。左操作数的值向左移动右操作数指定的位数。	A << 2 将得到 240，即为 1111 0000
>>	二进制右移运算符。左操作数的值向右移动右操作数指定的位数。	A >> 2 将得到 15，即为 0000 1111
````

## 杂项运算符
>下表列出了 C++ 支持的其他一些重要的运算符。
````
运算符	描述
sizeof	sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。
Condition ? X : Y	条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。
,	逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。
.（点）和 ->（箭头）	成员运算符用于引用类、结构和共用体的成员。
Cast	强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。
&	指针运算符 & 返回变量的地址。例如 &a; 将给出变量的实际地址。
*	指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。
````

## C++ 中的运算符优先级
````
类别 	运算符 	结合性 
后缀 	() [] -> . ++ - -  	从左到右 
一元 	+ - ! ~ ++ - - (type)* & sizeof 	从右到左 
乘除 	* / % 	从左到右 
加减 	+ - 	从左到右 
移位 	<< >> 	从左到右 
关系 	< <= > >= 	从左到右 
相等 	== != 	从左到右 
位与 AND 	& 	从左到右 
位异或 XOR 	^ 	从左到右 
位或 OR 	| 	从左到右 
逻辑与 AND 	&& 	从左到右 
逻辑或 OR 	|| 	从左到右 
条件 	?: 	从右到左 
赋值 	= += -= *= /= %=>>= <<= &= ^= |= 	从右到左 
逗号 	, 	从左到右 
````

## Lambda 函数与表达式
> C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。
> Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。
> Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:
	[capture](parameters)->return-type{body}
> 例如：
	[](int x, int y){ return x < y ; }
> 如果没有返回值可以表示为：
	[capture](parameters){body}
> 例如：
	[]{ ++global_x; } 
> 在一个更为复杂的例子中，返回类型可以被明确的指定如下：
	[](int x, int y) -> int { int z = x + y; return z + x; }
> 本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。
> 如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。
> 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：
	[]      // 沒有定义任何变量。使用未定义变量会引发错误。
	[x, &y] // x以传值方式传入（默认），y以引用方式传入。
	[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
	[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
	[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
	[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：
	[this]() { this->someFunc(); }();

## C++ 字符串
> C++ 提供了以下两种类型的字符串表示形式：
> - C 风格字符串
> - C++ 引入的 string 类类型

## C 风格字符串
> C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。
> 其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '\0' 放在字符串的末尾。
> C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:
````
序号	函数 & 目的
1	strcpy(s1, s2);
复制字符串 s2 到字符串 s1。
2	strcat(s1, s2);
连接字符串 s2 到字符串 s1 的末尾。
3	strlen(s1);
返回字符串 s1 的长度。
4	strcmp(s1, s2);
如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。
5	strchr(s1, ch);
返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
6	strstr(s1, s2);
返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。
````

## C++ 中的 String 类
> C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。

## C++ 指针
> 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。
> 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：
	type *var-name;
> 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：
	int    *ip;    /* 一个整型的指针 */
	double *dp;    /* 一个 double 型的指针 */
	float  *fp;    /* 一个浮点型的指针 */
	char   *ch;    /* 一个字符型的指针 */
> 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

## C++ 中使用指针
> 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：
	#include <iostream>
	using namespace std;
	int main ()
	{
	   int  var = 20;   // 实际变量的声明
	   int  *ip;        // 指针变量的声明
	   ip = &var;       // 在指针变量中存储 var 的地址
	   cout << "Value of var variable: ";
	   cout << var << endl;
	   // 输出在指针变量中存储的地址
	   cout << "Address stored in ip variable: ";
	   cout << ip << endl;
	   // 访问指针中地址的值
	   cout << "Value of *ip variable: ";
	   cout << *ip << endl;
	   return 0;
	}
> 当上面的代码被编译和执行时，它会产生下列结果：
	Value of var variable: 20
	Address stored in ip variable: 0xbfc601ac
	Value of *ip variable: 20

## C++ 引用
> 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。
> **C++ 引用 vs 指针**
> 引用很容易与指针混淆，它们之间有三个主要的不同：
> - 不存在空引用。引用必须连接到一块合法的内存。
> - 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
> - 引用必须在创建时被初始化。指针可以在任何时间被初始化。
> 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。
	#include <iostream>
	using namespace std;
	int main ()
	{
	   // 声明简单的变量
	   int    i;
	   double d;
	   // 声明引用变量
	   int&    r = i;
	   double& s = d;
	   i = 5;
	   cout << "Value of i : " << i << endl;
	   cout << "Value of i reference : " << r  << endl;
	   d = 11.7;
	   cout << "Value of d : " << d << endl;
	   cout << "Value of d reference : " << s  << endl;
	   return 0;
	}
> 当上面的代码被编译和执行时，它会产生下列结果：
	Value of i : 5
	Value of i reference : 5
	Value of d : 11.7
	Value of d reference : 11.7
> 引用通常用于函数参数列表和函数返回值。

## 可重载运算符/不可重载运算符
> - 下面是可重载的运算符列表：
````
双目算术运算符	+ (加)，-(减)，*(乘)，/(除)，% (取模)
关系运算符	==(等于)，!= (不等于)，< (小于)，> (大于>，<=(小于等于)，>=(大于等于)
逻辑运算符	||(逻辑或)，&&(逻辑与)，!(逻辑非)
单目运算符	+ (正)，-(负)，*(指针)，&(取地址)
自增自减运算符	++(自增)，--(自减)
位运算符	| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移)
赋值运算符	=, +=, -=, *=, /= , % = , &=, |=, ^=, <<=, >>=
空间申请与释放	new, delete, new[ ] , delete[]
其他运算符	()(函数调用)，->(成员访问)，->*(成员指针访问)，,(逗号)，[](下标)
````
> - 下面是不可重载的运算符列表：
````
.：成员访问运算符
.*, ->*：成员指针访问运算符
::：域运算符
sizeof：长度运算符
?:：条件运算符
#： 预处理符号
````

## 虚函数
> - 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
> 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
> - 纯虚函数
> 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。
> 我们可以把基类中的虚函数 area() 改写如下：
	class Shape {
	   protected:
	      int width, height;
	   public:
	      Shape( int a=0, int b=0)
	      {
	         width = a;
	         height = b;
	      }
	      // pure virtual function
	      virtual int area() = 0;
	};
> = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。

## C++ 接口（抽象类）
> 接口描述了类的行为和功能，而不需要完成类的特定实现。
> C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。
> 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的，如下所示：
	class Box
	{
	   public:
	      // 纯虚函数
	      virtual double getVolume() = 0;
	   private:
	      double length;      // 长度
	      double breadth;     // 宽度
	      double height;      // 高度
	};
> 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
> 因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
> 可用于实例化对象的类被称为具体类。

## C++析构函数（Destructor）
> 创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数。
> 析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。
> 注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。
